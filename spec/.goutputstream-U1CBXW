\input texinfo    @c -*-texinfo-*-
%
% bpm-sw-spec.in - main file for the documentation
%
%%%%

%------------------------------------------------------------------------------
%
%                         NOTE FOR THE UNAWARE USER
%                         =========================
%
%    This file is a texinfo source. It isn't the binary file of some strange
%    editor of mine. If you want ASCII, you should "make fine-delay.txt".
%
%------------------------------------------------------------------------------

%
% This is not a conventional info file...
% I use three extra features:
%   - The '%' as a comment marker, if at beginning of line ("\%" -> "%")
%   - leading blanks are allowed (this is something I can't live without)
%   - braces are automatically escaped when they appear in example blocks
%

@comment %**start of header
@documentlanguage en
@documentencoding ISO-8859-1
@setfilename bpm-sw-spec.info
@settitle bpm-sw-spec
@iftex
@afourpaper
@end iftex
@c @paragraphindent none

@c %**end of header

@c greek letters

@setchapternewpage off

@set update-month May 2013
@c @set release 1.0
@set tagname bpm-sw-spec-v1.0
@c WARNING: in @example I Can't use @value{tagname}, so please look for this
@c string when updating the document.
@finalout

@titlepage
@title BPM Firmware and Software Specification
@subtitle @value{update-month}
@subtitle BPM firmware and software specification document
@author CNPEM-LNLS DIG / Lucas Russo and Daniel Tavares
@end titlepage
@headings single

@c ##########################################################################
@iftex
@contents
@end iftex

@c ##########################################################################
@c @include my-bib-macros.texi
@c @mybibuselist{References}

@c ##########################################################################
@node Top
@top Introduction

This is the specfication document for the BPM firmware and software in
development on @code{http://www.ohwr.org/projects/bpm-sw}. This is meant to serve
as a reference guide on firmware FPGA and software developments. Also, it clarifies
the necessary functionality of the project.

@c ##########################################################################
@node Glossary
@chapter Glossary

@table @r

@item @i{deliverable}
    An entity that can have its scope and development time defined, such as:
    a FPGA firmware core, a software library, a manual, an specification.

@item @i{core}/@i{block}
    A logical boundary between parts of a system. It is usually referred to a
    well different subsystem wich have different funcionalities.

@item @i{EEPROM}
    Electrically Erasable Programmable Read-Only Memory. It is a type of non-volatile
    memory used to store small amounts of data, such as calibration and information
    data.

@item @i{word}
    Common granularity of a set of meaningful signals or pins in a determined
    context. For example, a word for the original RISC MIPS processor was
    defined as 32-bit and later extended to 64-bit.

@item @i{channel}
    A set of signals with a common or related meaning, such as a data channel,
    representing a stream of data words originating from a @i{source} and
    consumed at a @i{sink}.

@item @i{BPF}
    Band pass filter. It is used to reject out-of-band signals.

@end table

@c ##########################################################################
@node Project Description
@chapter Project Description

The Brazilian Synchrotron Light Laboratory (LNLS) is currently designing a
third-generation 3 GeV low emmitance synchrotron light source in Campinas,
Brazil, called Sirius, with first beam due to the second quarter of 2016.
The main parameters of the machine are sumarized in @ref{tab:sirius_param}.

@c FIX THIS TABLE! UPDATE!

@float Table,tab:sirius_param
@multitable @columnfractions .40 .25 .10
@item Parameter                 @tab      Value     @tab      Unit
@item Beam energy               @tab      3.0       @tab      @math{GeV}
@item Injection energy (top-up) @tab      3.0       @tab      @math{GeV}
@item Beam current              @tab      500       @tab      @math{mA}
@item RF frequency              @tab      500       @tab      @math{MHz}
@item Harmonic number           @tab      800       @tab      -
@item Natural bunch length      @tab      13.2      @tab      @math{ps}
@item Beam size on insertion
      devices @ 0.5% coupling
      (horizontal X vertical)   @tab   139.6-195.9
                                        x 2.6-5.6   @tab      @math{um}
@item Circumference (storage ring)
                                @tab    479.664     @tab      @math{m}
@end multitable
@caption{Sirius parameters}
@end float

@c ==========================================================================
@node EBPM Overview
@section EBPM Overview

In the context of the Sirius project, the Beam Diagnostics Group (DIG) of LNLS
has been called to develop a beam position monitoring eletronics system (EBPM)
which must provide electron beam position real-time monitoring, buffered data readouts,
fast orbit feedback capabilities and advanced beam diagnostics tools for the
new accelerator's injector and storage ring. This project is primarily intended
to deliver a BPM system for the Sirius machine. Nevertheless, it is made open
for the particle accelerators community and grand public for design reuse and
collaborative development.

The BPM electronics is decomposed into 3 main subsystems: RF front-end, ADC
board and digital back-end.

@c ==========================================================================
@node EBPM Description
@section EBPM Description

The RF front-end is designed for button BPM pick-ups and must allow 50 @math{dB} dynamic
range with maximum gain of 60 @math{dB} (0 to 5 @math{dBm} output). Bandpass filtering must
45 @math{MHz} bandwidth around the 500 MHz beam's main frequency, with 80 @math{dB} attenuation
in the stop band.

The ADC board is a FMC mezzanine fully compliant to ANSI/VITA 57.1, providing
4-channel 16-bit 130 @math{MSPS} (LTC2208IUP) with 200 @math{MHz} bandwidth around 500 @math{MHz}.
Clocking can be phase-locked to external reference or direct clock inputs.
Input/output triggers are also present. It is expected to achieve above 10 bits
ENOB and above 80 @math{dBFS} SFDR for 500 @math{MHz}.

The DBE is a bused system which integrates in a single enclosure BPM processing
boards (beam position sensor data processing, data acquisition, advanced diagnostics),
FOFB processing boards (feedback control) and a single board computer (control
system interface). The FPGA boards are connected to the single board computer
via PCIe link. The backplane provides power, JTAG chain access, PCIe switch and
point-to-point connection (multigigabit serial links, GPIO, triggers, clocks)
between the carriers' FPGAs.

@ref{fig:bpm_overview} depicts the aforementioned decomposition.

@float Figure,fig:bpm_overview
@center @image{img/bpm_overview, 16cm, , BPM Overview, png}
@caption{BPM Overview}
@end float
@sp 1

@c ##########################################################################
@node Project Information and Repositories
@chapter Project Information and Repositories

The project is hosted in the following places:

@c --------------------------------------------------------------------------

@noindent @b{Project Information:}
@table @r
@item BPM
    @code{http://www.ohwr.org/projects/bpm}

    Top project page for general BPM information. It also hosts the subprojects
    RFFE (RF Front-End), FMC ADC (ADC boards) and DBE (Digital Back-End) platform.
    The later is a microTCA system composed of a commercial crate, AMC CPU (PowerPC)
    and MCH (MicroController Hub, as required by the microTCA standard). Also, a
    custom, fully-compliant microTCA board named AFC (AMC FMC Carrier) is hosted
    in a repository mentioned below.
@end table

@c --------------------------------------------------------------------------

@noindent @b{Hardware Developments:}

@table @r
@item RFFE
    @code{http://www.ohwr.org/projects/bpm-rffe}

    Top project page for the RFFE hardware development.

@item
    @code{git://ohwr.org/bpm/bpm-rffe}
@itemx
    @code{git@@ohwr.org:bpm/bpm-rffe.git}

    Git repository for the RFFE hardware development.
@end table

@c --------------------------------------------------------------------------

@table @r
@item FMC ADC 130MSPS
    @code{http://www.ohwr.org/projects/fmc-adc-130m-16b-4cha}

    Top project page for the FMC ADC 130MSPS hardware development.

@item
    @code{git://ohwr.org/fmc-projects/fmc-adc-130m-16b-4cha}
@itemx
    @code{git@@ohwr.org:fmc-projects/fmc-adc-130m-16b-4cha.git}

    Git repository for the FMC ADC 130MSPS hardware development.
@end table

@c --------------------------------------------------------------------------

@table @r
@item FMC ADC 250MSPS
    @code{http://www.ohwr.org/projects/fmc-adc-250m-16b-4cha}

    Top project page for the FMC ADC 250MSPS hardware development.

@item
    @code{git://ohwr.org/fmc-projects/fmc-adc-250m-16b-4cha}
@itemx
    @code{git@@ohwr.org:fmc-projects/fmc-adc-250m-16b-4cha.git}

    Git repository for the FMC ADC 250MSPS hardware development.
@end table

@c --------------------------------------------------------------------------

@table @r
@item AFC
    @code{http://www.ohwr.org/projects/afc}

    Top project page for the AFC (part of the Digital Back-End) hardware
    development.

@item
    @code{git://ohwr.org/fmc-projects/afc}
@itemx
    @code{git@@ohwr.org:fmc-projects/afc.git}

    Git repository for the AFC hardware development.
@end table

@c --------------------------------------------------------------------------

@noindent @b{Firmware and Software Developments:}

@table @r
@item BPM-SW
    @code{http://www.ohwr.org/projects/bpm-sw}

    Top project page for the BPM firmware and software

@item
    @code{git://ohwr.org/fmc-projects/afc}
@itemx
    @code{git@@ohwr.org:fmc-projects/afc.git}

    Git repository for the BPM firmware and software development.
@end table

@c ##########################################################################
@node Support Projects and Repositories
@chapter Support Projects and Repositories

In order to provide a more structured development workflow and diminish rework and
redevelopments a set of support projects are employed. Also, it is highly advisable
to adhere to the HDL code style and standards.

These projects are hosted in the following places:

@c --------------------------------------------------------------------------

@noindent @b{Tools:}

@table @r
@item Wishbone Slave Generator
    @code{http://www.ohwr.org/projects/wishbone-gen}

    Top project page for the Wishbone Slave Generator information.

@item
    @code{git://ohwr.org/hdl-core-lib/wishbone-gen.git}

    Git repository for the Wishbone Slave Generator project information.

@item
    This project provides a mean of easilly interface a custom module to the Wishbone
    standard. It exports a simple C-like description language to the user and
    produces an interface VHDL/Verilog core, which connects to a Wishbone bus in one side
    and provides ports for accessing memory mapped registers, FIFOs and RAMs
    on the other (i.e., core) side. Also, it generates HTML and Texinfo documentation,
    Verilog and C headers register definitions.

    It is highly advisable to use this project in order to generate Wishbone interfaces.
@end table

@c --------------------------------------------------------------------------

@table @r
@item Hdlmake
    @code{http://www.ohwr.org/projects/hdl-make}

    Top project page for the Hdlmake project information.

@item
    @code{git://ohwr.org/misc/hdl-make.git}

    Git repository for the Hdlmake project.

@item
    This project is a tool for generating multi-purpose makefiles for FPGA projects,
    as stated on the main project webpage. It is possible to generate makefiles
    capable of fetching modules from repositories, dependency control over VHDL/
    Verilog files, simulating designs with ModelSim, ISim (planned) and Icarus
    Verilog (planned), synthesizing projects with Xilinx (i.e., ISE) or Altera
    (i.e., Quartus), remote-synthesis, among other features.

    A more complete documentation and the available features can be found at
    @code{http://www.ohwr.org/projects/hdl-make/wiki}.

    It is highly advisable to use this project in order to adhere to the projects
    standards.
@end table

@c --------------------------------------------------------------------------

@noindent @b{FPGA firmware support projects:}

@table @r
@item General Cores
    @code{http://www.ohwr.org/projects/general-cores}

    Top project page for the General Cores project information.

@item
    @code{git://ohwr.org/hdl-core-lib/wishbone-gen.git}

    Git repository for the General Cores project information.

@item
    This project comprises a collection of platform-independent cores for HDL firmware
    developments, such as memories, synchronizer circuits, communication protocols
    (e.g., SPI, I2C, One-Wire), among others.

    It is highly advisable to use the available cores for release code, as they are actively
    mantained and used by many other projects.
@end table

@c --------------------------------------------------------------------------

@table @r
@item FPGA Configuration Space
    @code{http://www.ohwr.org/projects/fpga-config-space}

    Top project page for the FPGA Configuration Space project information.

@item
    @code{git://ohwr.org/hdl-core-lib/fpga-config-space.git}

    Git repository for the FPGA Configuration Space information.

@item
    This project defines data structures, to be embedded in the FPGA memory address
    space, to enumerate the devices that have been synthetized in the current design.
    The same structure is also used as a simple flash file system,  AKA Self-Describing
    Bus (SDB) Specification for Logic Cores. The layout is simple enough to be parsed
    both by the host and by the internal soft-core, if any. The official specification
    can be found here @code{http://www.ohwr.org/attachments/download/2006/sdb-1.1.pdf}

    It is highly advisable to use the the structures defined in this project as
    it provides a mean of embedding meta-information into the FPGA project. One
    projects may be used as a ground base for using the FPGA configuration space
    project, as well as an actual use of the General-cores project cores: White-Rabbit
    Core Collection. It is described below.
@end table

@c --------------------------------------------------------------------------

@table @r
@item White-Rabbit Core Collection
    @code{http://www.ohwr.org/projects/wr-cores}

    Top project page for the White-Rabbit Core Collection project information.

@item
    @code{git://ohwr.org/hdl-core-lib/wr-cores.git}

    Git repository for the White-Rabbit Core Collection information.

@item
    This project is an implementation of a VHDL library containing the VHDL modules
    commonly used in a White Rabbit based network. This is aminly referenced here
    as an use case of the cores and structures defined in General Cores and FPGA
    Configuration Space projects.
@end table

@c --------------------------------------------------------------------------

@noindent @b{Development instructions:}

@table @r
@item Repository Layout
    The project repository layout should follow the conventions outlined below.
    This was based on the @code{Development Instructions} released by
    CERN ans is currently applied in @code{bpm-sw} repository.

    @verbatim
    Folder Hierarchy organization:

    *
    |
    |-- hdl:
    |    |   HDL (Verilog/VHDL) cores related to the BPM.
    |    |
    |    |-- ip_cores:
    |    |    |   Third party reusable modules, primarily
    |    |    |      Open hardware modules (http://www.ohwr.org).
    |    |    |
    |    |    |-- etherbone-core:
    |    |    |       Connects two Wishbone buses, either a true
    |    |    |         hardware bus or emulated software bus,
    |    |    |         through Ethernet.
    |    |    |-- general-cores (fork from original project):
    |    |            General reusable modules.
    |    |
    |    |-- modules:
    |    |    |   Modules specific to BPM hardware.
    |    |    |
    |    |    |-- custom_common:
    |    |    |       Common (reusable) modules to BPM hardware and
    |    |    |         possibly to other designs.
    |    |    |-- custom_wishbone:
    |    |            Wishbone modules to BPM hardware.
    |    |
    |    |-- platform:
    |    |        Platform-specific code, such as Xilinx Chipscope
    |    |          wrappers.
    |    |
    |    |-- sim:
    |    |        Generic simulation files, reusable Bus Functional
    |    |          Modules (BFMs), constants definitions.
    |    |
    |    |-- syn:
    |    |        Synthesis specific files (user constraints files and
    |    |          top design specification).
    |    |
    |    |-- testbench:
    |    |        Testbenches for modules and top level designs. May
    |    |          use modules defined elsewhere (specific within
    |    |          the 'sim" directory).
    |    |
    |    |-- top:
    |             Top design modules.
    |
    |-- sw:
    |    |    Software related to interfacing the BPM carrier board with a PC
    |    |      via PCIe.
    |    |
    |    |-- drivers:
    |    |        Linux Kernel code for device drivers
    |    |
    |    |-- include:
    |    |        Header files for device structures and definitions
    |    |
    |    |-- lib:
    |             Utilities and API functions exported by the drivers
    |
    |-- embedded-sw (based on the original project by Alessandrio Rubini
    |    |            and others  <http://www.ohwr.org/projects/wrpc-sw>):
    |    |
    |    |      Embedded software that runs inside the LM32 softcore processor.
    |    |
    |    |-- arch:
    |    |        Architecture specific code, like linker scripts and boot code.
    |    |
    |    |-- boards:
    |    |        Board specific parameters and initialization.
    |    |
    |    |-- dev:
    |    |        Device specific code, such as UART, GPIO and DMA interfaces
    |    |
    |    |-- include:
    |    |    |   General headers, mostly API device headers.
    |    |    |
    |    |    |-- hw:
    |    |    |       Device specific registers and structures. This definitions
    |    |    |         are included by the more general headers located inside
    |    |    |         the "include" top directory.
    |    |    |
    |    |    |-- memmgr:
    |    |            Memory pool for "dynamic" allocated memory.
    |    |
    |    |-- lib:
    |    |        Utilities and general functions, such as the memmgr subsystem
    |    |          and a printf-like function.
    |    |
    |    |-- tests:
    |    |        Folder dedicated to software testing.
    |    |
    |    |-- tools:
    |    |        General tools for generating RAM loadable file by the firmware
    |    |          FPGA.
    @end verbatim

@item Coding Style
    The coding style for all of the modules must follow the guidelines outlined
    in @code{Guidelines for VHDL Coding}, available at
    @code{http://www.ohwr.org/attachments/554/VHDLcoding.pdf}
    and the LNLS adaptations available at @code{publish LNLS adaptations}.
@end table

@c ##########################################################################
@node Definitions
@chapter Definitions

Throughout this document the following definitions are used to clarify the
importance of a particular statement or feature:

@table @r

@item MUST (NOT) / NEED (NOT) / NECESSARY
    These keywords are used to specify an obligatory requirement. The deliverable
    will not be compliant to this specification if not present.

@item MAY (NOT) / MIGHT
    These keywords are used to indicate that a specific requirement is desirable,
    but not obligatory. The deliverable will be compliant to this document if not
    present

@item SHOULD (NOT) / ADVISABLE (NOT)
    These keywords are used to indicate that a specific requirement is a suggestion,
    but it is advised to be followed or debated. The deliverable will be compliant
    to this document if not present.

@end table

@c ##########################################################################
@node Firmware Specification
@chapter Firmware Specification

The following sections will describe the general required funcionality of the
FPGA and each of the FPGA blocks as depicted in figure @ref{fig:bpm_firmware}.

@float Figure,fig:bpm_firmware
@center @image{img/bpm_firmware, 16cm, , BPM Firmware, png}
@caption{FPGA firmware}
@end float
@sp 1

@c ==========================================================================
@node Board Control and Status
@section Board Control and Status

This block contains all control and status registers related to the carrier
board regardless of the application. The minimal set of necessary information
is the following:

@table @r
@item @b{Bitstream type and date}
    In order to allow identification of the current FPGA bitstream it is necessary
    to have information about its type (constant value statically determined) and
    the date of its generation in UTC format (value determined at synthesis time).

@item @b{Bitstream meta-information}
    It is necessary to have a means of identify the project repositories and the
    current code maintainers. The Self-Describing Bus (SDB) standard developed
    by CERN and others supports this feature and must be used.

@item @b{Carrier temperature with continuous monitoring}
    The Carrier temperature needs to be continuously monitored for safety reasons.
    Upon exceeding a threshold, an interrupt should be generated to an interrupt
    controller and transmitted to the systems' upper layers, such as the Single
    Board Computer via PCIe.

    Also, a historic temperature readings buffer must be stored to allow posterior
    analysis and further processing of temperature values.

@item @b{Power supplies and FMC status}
    The Carrier power supplies needs to be monitored and stored to allow posterior
    analysis of voltage and current data. Typically, power supplies provides a
    power good signal to allow monitoring its status. Besides these signals,
    onboard measurements of power supplies' voltage and current values may
    be employed, acquired and stored to allow posterior alalysis and further
    processing.

    The Board status block needs to provide signals for detecting the presence
    of an FMC board and the status of its power supplies. These are common
    signals on FMC boards.

@end table

@c ==========================================================================
@node ADC Acquisition and Control Interface
@section ADC Acquisition and Control Interface

This block handles and communication with the FMC ADC board. There are three boards
with different parameters and CIs that needs to be supported: [1] Curtiss-Wright FMC516,
[2] OHWR FMC130M16B4CH and [3] OHWR FMC250M16B4CH.

Regardless of which board is being considered the following set of functionalities
must be supported:

@table @r

@item @b{ADC programability}

    The ADCs employed in all of the boards have configuration capabilities. Consequentely,
    the core must provide a means to interface them. This is typically done by
    reading/writing some ADC registers via SPI/@math{u}Wire.

@item @b{VCXO/VCO programability}

    The crystal oscillators employed in all of the boards have configuration
    capabilities. Consequentely, the core must provide a means to interface them.
    This is typically done by reading/writing some VCXO/VCO registers via I2C.

@item @b{Data Acquisition}

    The block must ensure data integrity for all available clock frequencies
    regardless of the ADC technology and mode of operation.

    The output of this block must be a set os data pins, representing all
    of the available ADC data channels and a single synchronous clock.
    The output format must be of two forms:

    @enumerate

    @item @i{Raw Interface}

        This interface is composed of a set of plain pins for the unprocessed ADC
        data for all of the available channels and a synchronous clock
        for downstream FPGA logic. An optional valid pin should be considered
        for qualifying the data channels. This could be a single signal
        for all of the ADC data channels or one signal for each ADC data
        channels.

    @item @i{Wishbone Streaming Interface}

        This interface is composed of Wishbone signals to allow streaming
        data with a backpressure scheme be supported. Each of the available
        data channels must have a separate set of wishbone streaming signals.
        A single synchronous clock is needed to be synchronous to all of the
        channels and must be available for downstream FPGA logic.

    @end enumerate

@item @b{Clock Selection and Programability}

    All of the boards support three types of clocking:

    @itemize @bullet
    @item @i{External direct clock}

        In this mode, the clock comes from an external source and is fed into the front
        panel connector which, in turn, is distributed by the clock distribution
        circuit to all ADCs chips and downstream FPGA logic.

    @item @i{External reference clock}

        In this mode a reference clock is fed into the front panel conector and, in turn,
        to a PLL circuit. This circuit is capable of generating various frequencies based
        on the onboard oscillator.The generated clock is distributed by the clock
        distribution circuit to all ADCs chips and downstream FPGA logic.

    @item @i{Internal clock}

        In this last mode, no external clock source is needed. The onboard oscillator in
        conjunction with the clock distribution circuit generates the clock to all ADC chips
        and downstream FPGA logic.

    @end itemize

    In order to support the operation described above, the core must implement all
    the necessary interface to select between the modes and provides a mean to select
    among the available frequencies. This typically involves writing via SPI to
    the clock distribution circuit, I2C to the programmable oscillator (VCXO)
    and direct setting some FPGA to FMC pins.

    The software support must provide a means to easilly select between the modes,
    selecting the desired clock frequency and reading/writing to all of the
    referenced FMC chips registers.

@item @b{Temperature Reading}

    The FMC board temperature must be monitored for safety and board integrity.
    Upon exceeding a threshold, an interrupt should be generated to an interrupt
    controller and transmitted to the systems' upper layers, such as the Single
    Board Computer via PCIe.

    Also, a historic temperature readings buffer must be stored to allow posterior
    analysis and further processing of temperature values.

@item @b{Supply Rails Reading}

    The FMC power rails needs to be continuously monitored for safety reasons.
    The core must provide support for acquiring and storing volage data.

    Also, a historic data buffer must be stored to allow posterior analysis and
    further processing of voltage values.

@item @b{EEPROM Support}

    The ANSI VITA57.1 FMC specification determines that an EEPROM is to be present
    in all FMC compliant boards. This memory stores hardware definition information
    as defined by FRU (Field Replaceable Unit) @cite{CITATION} definition. Therefore,
    the core must provide a means to read its contents.

    Also, the software support must provide utilities to interface the EEPROM, while
    keeping the design as platform-agnostic as possible.

@item @b{Fine Delay Support}

    It is necessary to be able to apply fine delay (in sub-nanoseconds granularity)
    for both data and clock individually for each path. This ensures timing flexibility for
    different FPGAs and carrier boards for data acquisition.

    The software support must provide a means of individually change the delay value
    for each data and clock paths. Individual bit fine-delay programmability should
    be considered.

@item @b{Automatic Fine Delay Calibration}
    An automatic calibration routine (preferrably in hardware) should be considered
    in order to allow independent setting of fine delay values for each data and clock
    paths.

    The routine should be executed periodically to adjust fine delay values in
    order to correct data and clock mismatches due to temperature drifts and other
    environmental parameters.

@c If you need this you probably have something wrong in your design! Right?
@c @item @b{Coarse Delay Support}
@c
@c     A coarse delay (in ADC clock cycles granularity) per data bit basis should be
@c     considered to allow synchronizing each data path.
@c
@c     This should be software controllable.
@c
@c @end table

@item @b{Trigger Support}

    There are commonly two types of external triggers on the FMC ADC boards.

    @enumerate

    @item @i{Trigger In}

        This trigger is available in the front panel as an input port. A single-ended
        trigger signal should be outputted to downstream FPGA logic.

    @item @i{Trigger Out}

        This trigger is available in the front panel as an output port. A single-ended
        trigger signal should be outputted to the FMC front panel connector.

    @end enumerate

    Both trigger ports should be outputted to downstream FPGA logic for further control.

@item @b{Additional EEPROM Support}

    If the board contains additional EEPROM memories, such as the Curtiss-Wright
    FMC516 board, it is necessary to have an interface to read/write to it.

    Also, the software support must provide utilities to interface the EEPROM, while
    keeping the design as platform-agnostic as possible.

@end table

@c ==========================================================================
@node Digital Signal Processing
@section Digital Signal Processing

    This block must provide ADC raw data and position measurement and amplitude
    values at various defined rates. It must be modular, in order to improve
    maintainability and robusetness.

@c --------------------------------------------------------------------------
@subsection Overview

    The digitized data needs to be conditioned through a series of digital filters,
    decimators and others algorithms in order to extract the position measurement data.
    Some of the sub-modules needed for this core are: Band-pass filter, Mixers,
    NCO (numerically controlled oscillator) FIR filters (direct form, transpose,
    polyphase structures and/or others), Half-band filters (decimate by two),
    CIC (Cascaded-Integrator comb) filter, CORDIC (COordinate Rotation DIgital
    Computer)and Difference over sum (Delta over sigma).

    The block must provide unprocessed ADC data at the ADC rate and position
    measurement in three different rates: Turn by Turn data (TBT), Fast Acquisition
    (FOFB) and Slow acquisition (Monitoring) data.

    The signal processing chain consists of an I/Q demodulation scheme followed
    by an amplitude detector and various stages of decimation. Finnaly, in possession
    of the amplitude of all four data channels, the delta-over-sum algorithm is
    calculated and the position data is produced.

    It is necessarry to provide signal processing chains in two versions: one for
    476.066 @math{MHz} RF frequency and another for 499.996 @math{MHz} RF frequency.
    This has a direct impact on the ADC clock, IF frequency, output rates and the
    decimation rate in each stage.

@c --------------------------------------------------------------------------
@subsection Description

    All unprocessed ADC data channels from the ADC interface block are necessary
    to be inputs to the digital signal processing block. Each of these channels
    must be individually processed, in order to extract the amplitude of the
    incoming signal.

    Typically, the signal is downconverted to baseband by mixing the incoming
    signal to a generated signal (e.g, DDS) of the same frequency and filtering
    the high frequency components. This is depicted in @ref{fig:dsp_473_overview}.
    The BPF in the beginning of the processing chain is generally used to avoid
    the self-mixing problem present when mixing signals.

    Following, it is necessary to decimate and detect the amplitude of the signal.
    The former should be done by a decimation filter, such as a FIR polyphase
    implementation. The latter should be done by employing a coordinate system
    change, as the data is presented in cartesian (i.e., I/Q) form and the amplitude
    value can be extracted by @math{-arctan(Q / I)}, polar coordinate variable.
    This can be accomplished by the use of CORDIC algorithm. FINISH this part!

    The @ref{fig:dsp_473_overview} depicts a possible implementation of a digital
    processing chain for 473.6 @math{MHz} RF frequency.

    @float Figure,fig:dsp_473_overview
    @center @image{img/dsp_473_overview, 16cm, , DSP Overview, png}
    @caption{DSP Overview}
    @end float
    @sp 1

@c --------------------------------------------------------------------------
@subsection Required Funcionalities

@table @r

@item @b{Data Output Format}
    The output of this block must be a set os data pins, representing all
    of the available processed channels and a single synchronous clock to the ADC.
    The output format must be of two forms in order to provide flexibility and room
    for further improvements:

    @enumerate

    @item @i{Raw Interface}

        This interface is composed of a set of plain pins for all of the processed
        ADC data channels and a single synchronous clock to the ADC for downstream
        FPGA logic. A valid pin must be used for qualifying the data channels.
        There must be a valid pin for each of the processed channels as they
        contain data in different, but correlated, frequencies.

    @item @i{Wishbone Streaming Interface}

        This interface is composed of Wishbone signals to allow streaming
        data with a backpressure scheme be supported. Each of the available
        data channels must have a separate set of Wishbone Streaming Signals.
        A single synchronous clock is needed to be synchronous to the ADC clock
        and must be available for downstream FPGA logic.

    @end enumerate

@end table

@c ==========================================================================
@node Data Acquisition
@section Data Acquisition

This subsystem is responsible for storing each type of data accordingly to the
specification (on demand or continuously through circular buffers), considering
the memory layout, memory controller (MPMC - multi port memory controller -
implementation is necessary) and loading the requested data to the SBC via PCIe
interface. Care must be taken when dealing with circular buffers for the
continuous data and CDC (clock domain crossing issues).

@c ==========================================================================
@node Data and Signal Correction
@section Data and Signal Correction

The data from the ADC may need additional amplification from the RFFE (RF front-
end) as well as channel de-switching (i.e., crossbar). These two features
compose the following: AGC (Automatic gain control) and RFFE interface in order
to automatic control the gain from the RFFE board; Scaler, concerning the digital
gain on the ADC data; Crossbar, regarding the channel de-switching introduced in
the RFFE.

@c ==========================================================================
@node Real-Time Data Distribution and Triggers
@section Real-Time Data Distribution and Triggers

It is necessary that the BPMs communicate with each other to exchange data and inter
BPM synchronization, therefore contemplating the FOFB (Fast Orbit Feedback)
system. Furthermore, external triggers, data-driven triggers and software triggers can
be employed to set data acquisition parameters.

@c ==========================================================================
@c @node @mybibnode{}
@c @chapter References
@c
@c @itemize @asis
@c
@c @mybibitem{LaTeX2e} Leslie Lamport, LaTeX User's Guide and
@c Reference Manual, 2nd edition, Addison-Wesley, Reading,
@c Massachusetts, 1994.
@c
@c @end itemize

@c ##########################################################################
@bye
